[{"content":" Name: Fxzou Email: fxzouv@gmail.com Java 后端开发 熟悉敏捷开发流程 ","permalink":"https://blog.fxzou.com/about/","summary":" Name: Fxzou Email: fxzouv@gmail.com Java 后端开发 熟悉敏捷开发流程 ","title":"关于我"},{"content":"从ReentrantLock看AQS (AbstractQueuedSynchronizer) 运行流程 概述 本文将以ReentrantLock为例来讲解AbstractQueuedSynchronizer的运行流程，主要通过源码的方式来讲解，仅包含大体的运行流程，不会过于深入。\nReentrantLock 介绍 ReentrantLock 是JDK提供的可重入锁实现类，可用其替换synchronized来实现锁重入效果；其底层实现主要是依靠AbstractQueuedSynchronizer，本文将通过ReentrantLock来观察AbstractQueuedSynchronizer的运行流程。\nAbstractQueuedSynchronizer 介绍 关于AbstractQueuedSynchronizer（以下简称AQS），JDK是这样子描述的：\nProvides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues.\n大体意思就是“提供一个框架，用于实现依赖于先进先出(FIFO)等待队列的阻塞锁和相关同步器(信号量、事件等)”，AQS不是一个功能完整的类，而是一个提供了一套依赖于FIFO等待队列的流程框架，该框架可用于实现锁等同步器的。AQS中没有使用任何锁相关的API，其实现主要依靠CAS (Compare And Swap)，是一个优秀的lock-free 编程实践。\nAQS数据结构 AQS中主要包含以下三个字段\n/** * Head of the wait queue, lazily initialized. Except for * initialization, it is modified only via method setHead. Note: * If head exists, its waitStatus is guaranteed not to be * CANCELLED. */ private transient volatile Node head; /** * Tail of the wait queue, lazily initialized. Modified only via * method enq to add new wait node. */ private transient volatile Node tail; /** * The synchronization state. */ private volatile int state; 这三个字段都标记了volatile，其中head 和 tail主要用于维护AQS的FIFO双向队列，该队列是AQS的核心，只由AQS该维护该队列，子类实现不会去维护该队列；state用于标记当前同步器的转态，AQS不会对该字段做任何操作，该字段由子类去维护，但AQS提供了修改state的方法，其中的compareAndSetState是子类用的最多的，主要用于实现多线程对同步器的抢夺。\nAQS 主要方法 在开始了解AQS的运行流程之前，我们先看一下在使用AQS时需要关注的四个方法：\n// 抢夺资源流程的入口，AQS暴露出的API，由自定义同步器来调用，ReentrantLock 的lock方法就是去调用该方法。 public final void acquire(int arg) { if (!tryAcquire(arg) \u0026amp;\u0026amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } // 由子类实现该方法，抢占资源逻辑在这个方法实现，该方法由AQS在抢夺资源流程中调用。 protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException(); } // 释放资源流程的入口，AQS暴露出的API，由自定义同步器来调用，ReentrantLock 的unlock方法就是去调用该方法。 public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null \u0026amp;\u0026amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } // 由子类实现该方法，释放资源逻辑在这个方法实现，该方法由AQS在释放资源流程中调用。 protected boolean tryRelease(int arg) { throw new UnsupportedOperationException(); } 其中acquire 和 tryAcquire 跟同步器资源抢夺相关；release 和 tryRelease 和同步器资源释放相关。acquire和release 方法是AQS流程的入口，通过这两个方法来走资源抢夺和资源释放的流程，该流程中包含了FIFO队列维护、\u0008线程状态管理等操作，是整个AQS的核心，自定义同步器中会去调用这两个方法；而tryAcquire和tryRelease 方法对应线程资源抢占和释放操作，这两个方法中只关心线程是否抢占/释放资源成功，不会维护FIFO队列和\u0008线程状态，由子类来实现这两个方法，这个是自定义同步器的核心代码，由这两个方法来实现不同同步器的不同功能。\n这四个方法对应的是线程独占流程，共享流程使用的是acquireShared, tryAcquireShared, releaseShared, tryReleaseShared 这四个方法，ReentrantLock是线程独占模式，所以本文主要讲解线程独占流程，但线程共享流程和独占流程差别不大，感兴趣的同学可以自行了解。\n下面看一下ReentrantLock中是如何去使用这四个方法的：\n// 简化版代码，方便演示 public class ReentrantLock implements Lock, Serializable { private final Sync sync = new Sync(); public void lock() { this.sync.acquire(1); } public void unlock() { this.sync.release(1); } static final class Sync extends AbstractQueuedSynchronizer { protected final boolean tryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { // 当前锁没有被占用 if (compareAndSetState(0, acquires)) { // 尝试去拿锁 setExclusiveOwnerThread(current); // 标记当前线程为锁的持有者 return true; // 返回拿锁成功 } } else if (current == getExclusiveOwnerThread()) { // 当前锁被占用，且是被自己占用，走重入逻辑，对state做累加 int nextc = c + acquires; if (nextc \u0026lt; 0) // overflow throw new Error(\u0026#34;Maximum lock count exceeded\u0026#34;); setState(nextc); return true; } // 锁被占用或者拿锁失败，返回拿锁失败 return false; } protected final boolean tryRelease(int releases) { int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) { // 锁被完全释放 free = true; // 标记锁已被释放 setExclusiveOwnerThread(null); } setState(c); return free; } } 可以看出，ReentrantLock的核心功能是由内部类Sync来完成的，而这个Sync类就是继承了AQS，并重写了tryAcquire 和 tryRelease 方法，这两个方法的实现也很简单\ntryAcquire 中主要是通过state字段是否等于0来判断当前锁是否锁住了，没有锁住，则当前线程使用CAS去尝试将state标记为acquires，标记成功则代表拿锁成功，返回true，否则返回false。 tryRelease 中则是通过判断释放后state是否为0来判断当前锁是否被完全释放，若完全释放则返回true，否则返回false。 可以看出这个两个方法的实现只关注锁的占用和释放是否成功，没有关心FIFO队列和\u0008线程状态。那么FIFO队列和\u0008线程状态是如何来维护的呢？答案就是在acquire和release 方法中；从ReentrantLock源码也可以看到，lock和unlock方法只是调用了一下acquire和release 方法，所以接下来我们重点来看一下这两个方法的实现\nNode 开始前，先看一下队列Node的数据结构\nstatic final class Node { static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; volatile int waitStatus; volatile Node prev; volatile Node next; volatile Thread thread; } 其中waitStatus字段代表了节点的等待状态，共包含了5个值。\nINIT(0): 节点的默认状态为0。当线程释放资源后，也会将自己的节点状态设置为0。 CANCELLED(1): 当前线程节点已取消等待，为CANCELLED的节点会在acquire方法里的流程中被清除。 SIGNAL(-1): 当前节点的后续节点已沉睡，需要被唤醒。会在release方法里的流程中将其后续节点唤醒。 CONDITION(-2) 和 PROPAGATE(-3) 则和条件锁及共享模式有关，本文不过多解释。 其中可以看出，状态可以分为两类，无效转态和有效状态，大于0则代表当前节点无效了，需要被移除，小于等于0则是有效节点，需要继续去尝试获取资源。\nacquire 先看一下acquire方法的实现\npublic final void acquire(int arg) { // 调用我们自己实现的tryAcquire去获取资源，获取失败则尝试将自己加入到等待队列中 if (!tryAcquire(arg) \u0026amp;\u0026amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 再看一下addWaiter方法\nprivate Node addWaiter(Node mode) { Node node = new Node(mode); // 为当前线程新建一个node，并将其加入到队列尾部，这里需要注意的是添加时是先将新节点的prev设置为老的尾部节点，使用CAS将新节点设置为tail后才会将老节点的next设置为新节点， // 这样做的理由是为了防止并发问题，后续的对队列的修改也是包括两种遍历，一个是从前往后，一个是从后往前。 for (;;) { Node oldTail = tail; if (oldTail != null) { node.setPrevRelaxed(oldTail); if (compareAndSetTail(oldTail, node)) { oldTail.next = node; return node; } } else { initializeSyncQueue(); } } } 添加完节点后，就会尝试去从队列中获取资源，这里也是AQS的核心了，看一下acquireQueued方法\nfinal boolean acquireQueued(final Node node, int arg) { boolean interrupted = false; try { for (;;) { // 取到当前节点的上一个节点 final Node p = node.predecessor(); // 如果上一个节点是头节点，则证明前面没有在等待的线程了，轮到当前线程去尝试获取资源。 if (p == head \u0026amp;\u0026amp; tryAcquire(arg)) { // 获取资源成功，则将当前节点设为头节点，并设置为空节点 setHead(node); p.next = null; // help GC return interrupted; } // 判断前面一个节点是否是一个有效的等待线程节点（没有取消等待的线程），是则将自己睡眠，不是则将前面已取消的线程节点移除，直到找到一个有效的线程节点作为自己的前序节点并将其状态设为SIGNAL，然后再走一次循环。 if (shouldParkAfterFailedAcquire(p, node)) interrupted |= parkAndCheckInterrupt(); } } catch (Throwable t) { cancelAcquire(node); if (interrupted) selfInterrupt(); throw t; } } 总结一下acquire方法的流程：\n调用子类实现的tryAcquire方法去获取资源。 获取成功则当前线程继续执行，否则将自己加入到等待队列。 进入等待队列后，循环的去判断自己的上一个节点是否是头结点，是则再次调用子类实现的tryAcquire方法去获取资源，否则进入沉睡，等待唤醒。 在沉睡前，会将前面已取消的线程节点移除，直到找到一个有效的线程节点做为自己的前序节点，并将其状态设为SIGNAL。 一句话就是acquire方法会去尝试获取资源，获取失败则将自己加入到等待队列，并沉睡，等待唤醒。\n举个例子，demo1线程获取资源失败后，当前的队列状态为： 若是有多个线程等待，则队列状态为： 由图可以看出，若当前节点已沉睡，则需要在沉睡前将前一个节点的转态设为SIGNAL。\nrelease 前面的acquire方法说到，等待队列中的线程会进入沉睡，等待唤醒，那么由谁来唤醒呢？答案就是release方法，也就是我们在调用unlock的时候，接下来我们先看一下release方法的实现\npublic final boolean release(int arg) { // 调用子类实现的tryRelease方法去释放资源 if (tryRelease(arg)) { Node h = head; // 释放成功，且等待队列中还有节点，则去唤醒下一个等待线程 if (h != null \u0026amp;\u0026amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } 再看一下unparkSuccessor方法\nprivate void unparkSuccessor(Node node) { int ws = node.waitStatus; if (ws \u0026lt; 0) node.compareAndSetWaitStatus(ws, 0); Node s = node.next; // 如果下一个节点已经取消了，则从后往前遍历，找到第一个等待线程节点 if (s == null || s.waitStatus \u0026gt; 0) { s = null; for (Node p = tail; p != node \u0026amp;\u0026amp; p != null; p = p.prev) if (p.waitStatus \u0026lt;= 0) s = p; } // 找到了等待线程节点，并将其唤醒 if (s != null) LockSupport.unpark(s.thread); } 唤醒后线程将会继续在acquireQueued方法里执行，并尝试再去获取资源。 总结一下release方法的流程：\n调用子类实现的tryRelease方法去释放资源 释放成功则判断当前队列是否有等待线程 有则找到第一个等待线程，并将其唤醒。 从流程上也可以看出，若tryRelease方法中抛了异常，则会导致所有沉睡的线程将无法被唤醒。\nAQS总结 AQS是模版设计模式的一种实践，其将线程调度等通用逻辑进行了实现，只预留了tryAcquire 和 tryRelease 方法供子类实现自己的并发工具，大大的减轻了实现的复杂难度。\n总结 ReentrantLock 是使用AQS实现的，其主要是实现了AQS的tryAcquire 和 tryRelease 方法，且只需要在lock和unlock方法中调用一下acquire和release 方法即可，可以看出AQS非常强大！\n参考文章 Java并发之AQS详解 从ReentrantLock的实现看AQS的原理及应用 ","permalink":"https://blog.fxzou.com/post/java/java_aqs/","summary":"","title":"从ReentrantLock看AQS (AbstractQueuedSynchronizer) 运行流程"},{"content":"用自定View的方式实现即刻APP的点赞效果。\n2016-12-5更新 修改测量逻辑 添加了对齐方式 添加了一个评论图形的GraphAdapter 修改了已知BUG 先看效果图 使用方法 布局配置 \u0026lt;cn.izouxiang.likeview.LikeView android:id=\u0026#34;@+id/lv\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; app:number=\u0026#34;99\u0026#34; /\u0026gt; 注意,一般不需要直接指定宽高,内部会根据字体大小自动测量\n代码配置 //点赞view的设置 holder.like.setActivated(entity.isLike); holder.like.setNumber(entity.likeNum); holder.like.setCallback(new LikeView.SimpleCallback() { @Override public void activate(LikeView view) { Snackbar.make(view, \u0026#34;你觉得\u0026#34; + entity.name + \u0026#34;很赞!\u0026#34;, Snackbar.LENGTH_SHORT).show(); } @Override public void deactivate(LikeView view) { Snackbar.make(view, \u0026#34;你取消了对\u0026#34; + entity.name + \u0026#34;的赞!\u0026#34;, Snackbar.LENGTH_SHORT).show(); } }); //评论view的设置 holder.comment.setNumber(entity.commentNum); //设置图形适配器 holder.comment.setGraphAdapter(CommentPathAdapter.getInstance()); holder.comment.setCallback(new LikeView.SimpleCallback(){ @Override public boolean onClick(LikeView view) { Snackbar.make(view, \u0026#34;你点击\u0026#34; + entity.name + \u0026#34;的评论按钮\u0026#34;, Snackbar.LENGTH_SHORT).show(); //返回true代表拦截此次点击,不使用默认的点击事件 return true; } }); 自定义图形适配器 public class CommentPathAdapter implements LikeView.GraphAdapter { private static CommentPathAdapter instance; private static final float xOffsetScale = 0.06f; private static final float yOffsetScale = 0.2f; //可用单例模式 public static CommentPathAdapter getInstance() { synchronized (CommentPathAdapter.class) { if (null == instance) { instance = new CommentPathAdapter(); } } return instance; } //这里绘制你想要的图形 @Override public Path getGraphPath(LikeView view, int length) { Path path = new Path(); int dx = (int) (length * xOffsetScale); int dy = (int) (length * yOffsetScale); int w = (int) (length * (1 - xOffsetScale * 2)); int h = (int) (length * (1 - yOffsetScale * 2)); path.moveTo(dx, dy); path.lineTo(dx + w, dy); path.lineTo(dx + w, dy + h); path.lineTo(dx + (w * 0.35f), dy + h); path.lineTo(dx + (w * 0.1f), dy + (h * 1.4f)); path.lineTo(dx + (w * 0.1f), dy + h); path.lineTo(dx, dy + h); path.lineTo(dx, dy); return path; } } 自定义配置 \u0026lt;resources\u0026gt; \u0026lt;declare-styleable name=\u0026#34;LikeView\u0026#34;\u0026gt; \u0026lt;!--当前数值,默认0--\u0026gt; \u0026lt;attr name=\u0026#34;number\u0026#34; format=\u0026#34;integer\u0026#34;/\u0026gt; \u0026lt;!--数字颜色,默认#888888--\u0026gt; \u0026lt;attr name=\u0026#34;textColor\u0026#34; format=\u0026#34;color\u0026#34;/\u0026gt; \u0026lt;!--图形外边颜色,默认#888888--\u0026gt; \u0026lt;attr name=\u0026#34;graphColor\u0026#34; format=\u0026#34;color\u0026#34;/\u0026gt; \u0026lt;!--当前激活时图形颜色,默认#ca5f5f--\u0026gt; \u0026lt;attr name=\u0026#34;animateColor\u0026#34; format=\u0026#34;color\u0026#34;/\u0026gt; \u0026lt;!--字体大小,决定控件高度以及图形大小,默认14sp--\u0026gt; \u0026lt;attr name=\u0026#34;textSize\u0026#34; format=\u0026#34;dimension\u0026#34;/\u0026gt; \u0026lt;!--动画时间,默认300--\u0026gt; \u0026lt;attr name=\u0026#34;animateDuration\u0026#34; format=\u0026#34;integer\u0026#34;/\u0026gt; \u0026lt;!--图形与数字间的距离,默认3dp--\u0026gt; \u0026lt;attr name=\u0026#34;distance\u0026#34; format=\u0026#34;dimension\u0026#34;/\u0026gt; \u0026lt;!--图形与数字高度的比例,默认1.3--\u0026gt; \u0026lt;attr name=\u0026#34;graphTextHeightRatio\u0026#34; format=\u0026#34;float\u0026#34;/\u0026gt; \u0026lt;!--图形外边绘制宽度,默认3dp--\u0026gt; \u0026lt;attr name=\u0026#34;graphStrokeWidth\u0026#34; format=\u0026#34;dimension\u0026#34;/\u0026gt; \u0026lt;!--数字绘制宽度,默认2dp--\u0026gt; \u0026lt;attr name=\u0026#34;textStrokeWidth\u0026#34; format=\u0026#34;dimension\u0026#34;/\u0026gt; \u0026lt;!--是否激活,默认false--\u0026gt; \u0026lt;attr name=\u0026#34;isActivated\u0026#34; format=\u0026#34;boolean\u0026#34;/\u0026gt; \u0026lt;!--是否自动测量数字修改后的宽度改变,防止更改状态时控件宽度改变,默认开启--\u0026gt; \u0026lt;attr name=\u0026#34;autoMeasureMaxWidth\u0026#34; format=\u0026#34;boolean\u0026#34;/\u0026gt; \u0026lt;!--是否不允许取消点赞,默认false--\u0026gt; \u0026lt;attr name=\u0026#34;notAllowedCancel\u0026#34; format=\u0026#34;boolean\u0026#34;/\u0026gt; \u0026lt;!--对齐方式,前三种默认垂直居中--\u0026gt; \u0026lt;attr name=\u0026#34;gravity\u0026#34; format=\u0026#34;enum\u0026#34;\u0026gt; \u0026lt;!--居中--\u0026gt; \u0026lt;enum name=\u0026#34;center\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;!--左对齐--\u0026gt; \u0026lt;enum name=\u0026#34;left\u0026#34; value=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;!--右对齐--\u0026gt; \u0026lt;enum name=\u0026#34;right\u0026#34; value=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;!--开始点--\u0026gt; \u0026lt;enum name=\u0026#34;start\u0026#34; value=\u0026#34;4\u0026#34;/\u0026gt; \u0026lt;/attr\u0026gt; \u0026lt;/declare-styleable\u0026gt; \u0026lt;/resources\u0026gt; 接口 /** * 事件监听接口 */ public interface Callback { /** * 点击事件监听 * * @param view 当前View * @return 返回true则代表不使用默认的点击事件 */ boolean onClick(LikeView view); /** * 变为激活状态 * * @param view 当前View */ void activate(LikeView view); /** * 变为不激活状态 * * @param view 当前View */ void deactivate(LikeView view); } /** * 获取图形Path接口 */ public interface GraphAdapter { /** * 获取图形的Path * * @param view 当前View * @param length 可绘制图形区域正方形的边长 * @return 带有图形的Path */ Path getGraphPath(LikeView view, int length); } 声明 此项目为练手项目,当中可能存在BUG,发现BUG请指出,谢谢 github地址 欢迎Star\n","permalink":"https://blog.fxzou.com/post/android/like_view/","summary":"\u003cp\u003e用自定View的方式实现即刻APP的点赞效果。\u003c/p\u003e","title":"仿即刻APP点赞桃心的效果"},{"content":"JoinPoint 对象 JoinPoint对象封装了SpringAop中切面方法的信息,在切面方法中添加JoinPoint参数,就可以获取到封装了该方法信息的JoinPoint对象.\n常用API 方法名 功能 Signature getSignature(); 获取封装了署名信息的对象,在该对象中可以获取到目标方法名,所属类的Class等信息 Object[] getArgs(); 获取传入目标方法的参数对象 Object getTarget(); 获取被代理的对象 Object getThis(); 获取代理对象 ProceedingJoinPoint对象 ProceedingJoinPoint对象是JoinPoint的子接口,该对象只用在@Around的切面方法中, 添加了以下两个方法。\nObject proceed() throws Throwable //执行目标方法 Object proceed(Object[] var1) throws Throwable //传入的新的参数去执行目标方法 Demo 切面类 @Aspect @Component public class aopAspect { /** * 定义一个切入点表达式,用来确定哪些类需要代理 * execution(* aopdemo.*.*(..))代表aopdemo包下所有类的所有方法都会被代理 */ @Pointcut(\u0026#34;execution(* aopdemo.*.*(..))\u0026#34;) public void declareJoinPointerExpression() {} /** * 前置方法,在目标方法执行前执行 * @param joinPoint 封装了代理方法信息的对象,若用不到则可以忽略不写 */ @Before(\u0026#34;declareJoinPointerExpression()\u0026#34;) public void beforeMethod(JoinPoint joinPoint){ System.out.println(\u0026#34;目标方法名为:\u0026#34; + joinPoint.getSignature().getName()); System.out.println(\u0026#34;目标方法所属类的简单类名:\u0026#34; + joinPoint.getSignature().getDeclaringType().getSimpleName()); System.out.println(\u0026#34;目标方法所属类的类名:\u0026#34; + joinPoint.getSignature().getDeclaringTypeName()); System.out.println(\u0026#34;目标方法声明类型:\u0026#34; + Modifier.toString(joinPoint.getSignature().getModifiers())); //获取传入目标方法的参数 Object[] args = joinPoint.getArgs(); for (int i = 0; i \u0026lt; args.length; i++) { System.out.println(\u0026#34;第\u0026#34; + (i+1) + \u0026#34;个参数为:\u0026#34; + args[i]); } System.out.println(\u0026#34;被代理的对象:\u0026#34; + joinPoint.getTarget()); System.out.println(\u0026#34;代理对象自己:\u0026#34; + joinPoint.getThis()); } /** * 环绕方法,可自定义目标方法执行的时机 * @param pjd JoinPoint的子接口,添加了 * Object proceed() throws Throwable 执行目标方法 * Object proceed(Object[] var1) throws Throwable 传入的新的参数去执行目标方法 * 两个方法 * @return 此方法需要返回值,返回值视为目标方法的返回值 */ @Around(\u0026#34;declareJoinPointerExpression()\u0026#34;) public Object aroundMethod(ProceedingJoinPoint pjd){ Object result = null; try { //前置通知 System.out.println(\u0026#34;目标方法执行前...\u0026#34;); //执行目标方法 //result = pjd.proeed(); //用新的参数值执行目标方法 result = pjd.proceed(new Object[]{\u0026#34;newSpring\u0026#34;,\u0026#34;newAop\u0026#34;}); //返回通知 System.out.println(\u0026#34;目标方法返回结果后...\u0026#34;); } catch (Throwable e) { //异常通知 System.out.println(\u0026#34;执行目标方法异常后...\u0026#34;); throw new RuntimeException(e); } //后置通知 System.out.println(\u0026#34;目标方法执行后...\u0026#34;); return result; } } 被代理类 /** * 被代理对象 */ @Component public class TargetClass { /** * 拼接两个字符串 */ public String joint(String str1, String str2) { return str1 + \u0026#34;+\u0026#34; + str2; } } 测试类 public class TestAop { @Test public void testAOP() { //1、创建Spring的IOC的容器 ApplicationContext ctx = new ClassPathXmlApplicationContext(\u0026#34;classpath:bean.xml\u0026#34;); //2、从IOC容器中获取bean的实例 TargetClass targetClass = (TargetClass) ctx.getBean(\u0026#34;targetClass\u0026#34;); //3、使用bean String result = targetClass.joint(\u0026#34;spring\u0026#34;,\u0026#34;aop\u0026#34;); System.out.println(\u0026#34;result:\u0026#34; + result); } } 输出结果 目标方法执行前... 目标方法名为:joint 目标方法所属类的简单类名:TargetClass 目标方法所属类的类名:aopdemo.TargetClass 目标方法声明类型:public 第1个参数为:newSpring 第2个参数为:newAop 被代理的对象:aopdemo.TargetClass@4efc180e 代理对象自己:aopdemo.TargetClass@4efc180e (和上面一样是因为toString方法也被代理了) 目标方法返回结果后... 目标方法执行后... result:newSpring+newAop 声明 本文章属于笔者的学习笔记,若内容有误,还请赐教!谢谢\n参考文章: http://blog.csdn.net/ochangwen/article/details/52557724 http://blog.csdn.net/a9529lty/article/details/7031070\n","permalink":"https://blog.fxzou.com/post/java/spring_joinpoint/","summary":"","title":"Spring JoinPoint的用法"},{"content":"Dagger2是Android中比较热门的依赖注入框架, 本文将从初学者的角度来学习Dagger2。\n2016-12-21 更新:添加@Subcomponent注解以及Lazy与Provider的使用,本文基本完结!如果有好的建议请提出,感谢大家的支持,谢谢\n依赖注入 Dagger2是Android中比较热门的依赖注入框架,什么是依赖注入呢?维基百科上是这样描述的:\n控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中.\n通俗的来讲呢,就是一个类中需要依赖其他对象时,不需要你亲自为那些需要依赖的对象赋值,为那些对象赋值的操作交给了IOC框架.\nDagger2介绍 一般的IOC框架都是通过反射来实现的,但Dagger2作为Android端的IOC框架,为了不影响性能,它是通过apt动态生成代码来实现的. Dagger2主要分为三个模块:\n依赖提供方Module,负责提供依赖中所需要的对象,实际编码中类似于工厂类 依赖需求方实例,它声明依赖对象,它在实际编码中对应业务类,例如Activity,当你在Activity中需要某个对象时,你只要在其中声明就行,声明的方法在下面会讲到. 依赖注入组件Component,负责将对象注入到依赖需求方,它在实际编码中是一个接口,编译时Dagger2会自动为它生成一个实现类. Dagger2的主要工作流程分为以下几步:\n将依赖需求方实例传入给Component实现类 Component实现类根据依赖需求方实例中依赖声明,来确定该实例需要依赖哪些对象 确定依赖对象后,Component会在与自己关联的Module类中查找有没有提供这些依赖对象的方法,有的话就将Module类中提供的对象设置到依赖需求方实例中 通俗上来讲就好比你现在需要一件衣服,自己做太麻烦了,你就去商店买,你跟商店老板说明你想要购买的类型后,商店老板就会在自己的衣服供应商中查找有没有你所说的类型,有就将它卖给你.其中你就对应上面所说的依赖需求方实例,你只要说明你需要什么,商店老板则对应Component实现类,负责满足别人的需求,而衣服供应商则对应Module类,他负责生产衣服.也许这里有点绕,但经过下面的Demo,也许能够帮助你理解.\n书写Demo 引入Dagger2 在项目下的build.gradle文件中添加apt插件:\nbuildscript { ... dependencies { classpath \u0026#39;com.android.tools.build:gradle:2.2.2\u0026#39; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files //添加apt插件 classpath \u0026#39;com.neenbedankt.gradle.plugins:android-apt:1.8\u0026#39; } } ... 在app目录的build.gradle文件中添加:\n//应用apt插件 apply plugin: \u0026#39;com.neenbedankt.android-apt\u0026#39; ... dependencies { ... //引入dagger2 compile \u0026#39;com.google.dagger:dagger:2.4\u0026#39; apt \u0026#39;com.google.dagger:dagger-compiler:2.4\u0026#39; //java注解 provided \u0026#39;org.glassfish:javax.annotation:10.0-b28\u0026#39; } 编写布料类Cloth 写一个Cloth类用作依赖对象,它包含一个color属性\npublic class Cloth { private String color; public String getColor() { return color; } public void setColor(String color) { this.color = color; } @Override public String toString() { return color + \u0026#34;布料\u0026#34;; } } 书写Module类 现在的需求是MainActivity中需要使用到Cloth对象,所以我们要为MainActivity书写一个Module类用来提供Cloth对象,相当于创建了一个提供商\n@Module public class MainModule { @Provides public Cloth getCloth() { Cloth cloth = new Cloth(); cloth.setColor(\u0026#34;红色\u0026#34;); return cloth; } } 嗯?怎么多了两个注解?这两个注解有什么用呢? 注解是Dagger2中的关键,编写Module类时要在该类上声明@Module以表明该类是Module类,这样Dagger2才能识别,那@Provides又是干嘛的呢?它的作用是声明Module类中哪些方法是用来提供依赖对象的,当Component类需要依赖对象时,他就会根据返回值的类型来在有@Provides注解的方法中选择调用哪个方法.在一个方法上声明@Provides注解,就相当于创建了一条生产线,这条生产线的产物就是方法的返回值类型.有了这条生产线,供应商就能提供这种类型的商品了,当商店老板发现有人需要这种类型的商品时,供应商就可以提供给他了\n书写Component接口 @Component(modules=MainModule.class) public interface MainComponent { void inject(MainActivity mainActivity); } 和Module类一样,Component类也是需要注解声明的,那个注解就是@Component,但是@Component注解的作用可不是单单用来声明Component类,他还有更强大的功能,@Component注解有modules和dependencies两个属性,这两个属性的类型都是Class数组,modules的作用就是声明该Component含有哪几个Module,当Component需要某个依赖对象时,就会通过这些Module类中对应的方法获取依赖对象,MainComponent中只包含MainModule,所以令modules=MainModule.class,相当于供应商和商店老板确定合作关系的合同.而dependencies属性则是声明Component类的依赖关系,这个下面再详讲. 接口中那个方法又是干嘛用的呢? 我们现在只是声明了Component类,但我们要怎么将Component类和依赖需求方对象联合起来呢?答案就是通过这个inject方法,这个方法可以将依赖需求方对象送到Component类中,Component类就会根据依赖需求方对象中声明的依赖关系来注入依赖需求方对象中所需要的对象,本Demo中MainActivity中需要Cloth对象,所以我们通过inject方法将MainActivity实例传入到MainComponent中,MainComponent就会从MainModule中的getCloth方法获取Cloth实例,并将该实例赋值给MainActivity中的cloth字段.相当于你去商店的道路,没有这条路,你就无法去商店和老板说明你所需要的东西.但是这里需要注意的是,inject方法的参数不能用父类来接收,例如本Demo中,如果inject的参数是Activity,那么Dagger2就会报错.\n在MainActivity中声明 public class MainActivity extends AppCompatActivity { private TextView tv; @Inject Cloth cloth; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv = (TextView) findViewById(R.id.tv); MainComponent build = DaggerMainComponent.builder().mainModule(new MainModule()).build(); build.inject(this); tv.setText(\u0026#34;我现在有\u0026#34; + cloth); } } 上面代码中有两处关键:\n声明依赖对象Cloth,就是在cloth字段上添加@Inject注解,Dagger2中声明依赖对象都是通过@Inject注解,但是@Inject注解的字段不能是private和protected的. 通过Dagger2自动生成的类来创建Component的实现类,创建时需要传入该Component实现类所需要的Module类实例,传入方法就是调用Module类类名首字母小写对应的方法.这里我们通过Dagger2自动生成的DaggerMainComponent类创建了MainComponent的实例,相当于我们创建了一个实实在在的商店,不再是理论上的商店,但是创建商店一定也要创建真实的供应商嘛,所以创建Component实现类时一定要传入Module的实例.(注意编写完Component接口后Dagger2并不会自动创建对应的类,需要我们点击Android Studio中bulid菜单下的Rebulid Poject选项,或者直接书写代码,编译时Dagger2就会帮你自动生成). 再将MainActivity通过inject方法发送到MainComponent中,调用完inject方法后,你就会发现,MainActivity中的cloth字段已经被赋值,而且该cloth对应的就是我们在MainModule类getCloth方法中创建的Cloth对象. 结果 另一种方法 前面的Demo可能给人最大的感受就是麻烦吧?就是为cloth赋个值,又要写什么Module类,又是要写什么Component接口.其实Dagger2还可以用注解来提供依赖对象.让我们来瞧瞧怎么使用.\n创建依赖类Shoe 我们又创建一个依赖类Shoe\npublic class Shoe { @Inject public Shoe() { } @Override public String toString() { return \u0026#34;鞋子\u0026#34;; } } 但是这次我们创建的方式和Cloth不一样了,我们在构造函数上声明了@Inject注解,这个注解有什么用呢?作用可大了,当Component在所拥有的Module类中找不到依赖需求方需要类型的提供方法时,Dagger2就会检查该需要类型的有没有用@Inject声明的构造方法,有则用该构造方法创建一个. 相当于你去商店购买东西,你需要的东西商店的供应商不生产,商店老板就只好帮你去网上看看有没有你需要的东西,有则帮你网购一个.(假设你不会网购,哈哈^ ^).\n在MainActivity中声明Shoe依赖 我们修改之前的MainActivity,添加一点东西\npublic class MainActivity extends AppCompatActivity { ... @Inject Shoe shoe; @Override protected void onCreate(Bundle savedInstanceState) { ... tv.setText(\u0026#34;我现在有\u0026#34; + cloth + \u0026#34;和\u0026#34; + shoe); } } 结果 注意 有些读者可能会这样想:为什么不都用这种方法来声明呢?为什么要用Module类? 答案是这样的,项目中我们会用到别人的jar包,我们无法修改别人的源码,就更别说在人家的类上添加注解了,所以我们只能通过Module类来提供.\n复杂一点的情况 我们创建的这些依赖类都不用依赖于其它依赖类,但是如果需要依赖于其它依赖类又要怎么弄呢?\n创建依赖类Clothes 我们又来创建一个衣服类Clothes,制作衣服时需要布料,所以我们在创建Clothes的实例时需要用到Cloth实例\npublic class Clothes { private Cloth cloth; public Clothes(Cloth cloth) { this.cloth = cloth; } public Cloth getCloth() { return cloth; } @Override public String toString() { return cloth.getColor() + \u0026#34;衣服\u0026#34;; } } 在Module类中增加提供方法 现在我们的MainActivity中需要依赖于Clothes对象,所以我们在MianModule中添加提供Clothes对象的方法,但是Clothes需要依赖于Cloth对象,这要怎么办呢?可能最先想到的办法就是这样:\n@Provides public Clothes getClothes(){ Cloth cloth = new Cloth(); cloth.setColor(\u0026#34;红色\u0026#34;); return new Clothes(cloth); } 直接在方法中创建一个Cloth不就得了,但是你有没有发现,创建Cloth的代码已经在getCloth方法中有了,我们能不能用getCloth方法中创建的Cloth实例来创建Clothes实例呢? Dagger2提供了这样的功能,我们只要在getClothes方法中添加Cloth参数,Dagger2就会像帮依赖需求方找依赖对象一样帮你找到该方法依赖的Cloth实例,所以我们代码可以这样改:\n@Provides public Clothes getClothes(Cloth cloth){ return new Clothes(cloth); } 在MainActivity中声明Clothes依赖 我们修改之前的MainActivity,添加一点东西\npublic class MainActivity extends AppCompatActivity { ... @Inject Clothes clothes; @Override protected void onCreate(Bundle savedInstanceState) { ... tv.setText(\u0026#34;我现在有\u0026#34; + cloth + \u0026#34;和\u0026#34; + shoe + \u0026#34;和\u0026#34; + clothes); } } 结果 依赖总结 同理,在带有@Inject注解的构造函数要是依赖于其它对象,Dagger2也会帮你自动注入.笔者就不测试了,希望读者亲测一下. 这里我们引用依赖注入神器：Dagger2详解系列中的一段话:\n我们有两种方式可以提供依赖，一个是注解了@Inject的构造方法，一个是在Module里提供的依赖，那么Dagger2是怎么选择依赖提供的呢，规则是这样的：\n步骤1：查找Module中是否存在创建该类的方法。 步骤2：若存在创建类方法，查看该方法是否存在参数 步骤2.1：若存在参数，则按从步骤1开始依次初始化每个参数 步骤2.2：若不存在参数，则直接初始化该类实例，一次依赖注入到此结束 步骤3：若不存在创建类方法，则查找Inject注解的构造函数，看构造函数是否存在参数 步骤3.1：若存在参数，则从步骤1开始依次初始化每个参数 步骤3.2：若不存在参数，则直接初始化该类实例，一次依赖注入到此结束 也就说Dagger2会递归的提供依赖.\n@Named和@Qulifier注解的使用 @Named 假设我们现在又有了新的需求,MainActivity中需要两种布料,分别是红布料和蓝布料,但我们的MainModule类中只能提供红布料,怎么办呢? 读者可能会想:在MainModule类中再添加一个提供蓝布料的方法不就行了:\n@Provides public Cloth getRedCloth() { Cloth cloth = new Cloth(); cloth.setColor(\u0026#34;红色\u0026#34;); return cloth; } @Provides public Cloth getBlueCloth() { Cloth cloth = new Cloth(); cloth.setColor(\u0026#34;蓝色\u0026#34;); return cloth; } 可问题就来了,Dagger2是通过返回值类型来确定的,当你需要红布料时,它又怎么知道哪个是红布料呢?所以Dagger2为我们提供@Named注解,它怎么使用呢?它有一个value值,用来标识这个方法是给谁用的.修改我们的代码:\n@Provides @Named(\u0026#34;red\u0026#34;) public Cloth getRedCloth() { Cloth cloth = new Cloth(); cloth.setColor(\u0026#34;红色\u0026#34;); return cloth; } @Provides @Named(\u0026#34;blue\u0026#34;) public Cloth getBlueCloth() { Cloth cloth = new Cloth(); cloth.setColor(\u0026#34;蓝色\u0026#34;); return cloth; } 我们在getRedCloth方法上使用@Named(\u0026quot;red\u0026quot;)表明此方法返回的是红布料,同理,在getBlueCloth方法上使用@Named(\u0026quot;blue\u0026quot;)表明此方法返回的是蓝布料,接下我们只要在MainActivity中的布料字段上同样使用@Named注解,就可以一一配对了.\npublic class MainActivity extends AppCompatActivity { ... @Inject @Named(\u0026#34;red\u0026#34;) Cloth redCloth; @Inject @Named(\u0026#34;blue\u0026#34;) Cloth blueCloth; @Override protected void onCreate(Bundle savedInstanceState) { ... tv.setText(\u0026#34;我现在有\u0026#34; + redCloth + \u0026#34;和\u0026#34; + blueCloth ); } } 在redCloth上用@Named(\u0026quot;red\u0026quot;)标记后,他就会对应Module中对应的方法.\n结果 @Qulifier @Qulifier功能和@Named一样,并且@Named就是继承@Qulifier的,我们要怎么使用@Qulifier注解呢?答案就是自定义一个注解:\n@Qualifier @Retention(RetentionPolicy.RUNTIME) public @interface RedCloth { } 有了这个注解,我们就可以用它在替换掉上面的@Named(\u0026quot;red\u0026quot;),效果是一样的.读者可以亲自试一试. 而且这两个注解还能使用在依赖参数上,比如这个:\n@Provides public Clothes getClothes(@Named(\u0026#34;blue\u0026#34;) Cloth cloth){ return new Clothes(cloth); } 效果和上面说明的一样,进入这个方法的cloth由上面有@Named(\u0026quot;blue\u0026quot;)的方法提供\n@Singleton和@Scope的使用 @Singleton 假设现在MainActivity中需要依赖Clothes和Cloth,我们在MainModule中提供这两个类的提供方法:\n@Module public class MainModule { @Provides public Cloth getRedCloth() { Cloth cloth = new Cloth(); cloth.setColor(\u0026#34;红色\u0026#34;); return cloth; } @Provides public Clothes getClothes(Cloth cloth){ return new Clothes(cloth); } } 接着在MainActivity中声明:\npublic class MainActivity extends AppCompatActivity { private TextView tv; @Inject Cloth redCloth; @Inject Clothes clothes; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv = (TextView) findViewById(R.id.tv); MainComponent build = DaggerMainComponent.builder().mainModule(new MainModule()).build(); build.inject(this); tv.setText(\u0026#34;redCloth=clothes中的cloth吗?:\u0026#34; + (redCloth == clothes.getCloth())); } } 运行结果:\n你会发现,MainActivity中的Cloth对象和Clothes中的Cloth对象并不是同一个对象,注入过程中,对cloth注入时会调用一次getRedCloth方法,创建了一个Cloth对象;注入Clothes时又会调用一次getRedCloth方法,这时又会创建一个Cloth对象,所以才会出现上面的结果.但是如果需要MainActivity中的Cloth对象和Clothes中的Cloth对象是同一个对象又要怎么办呢?Dagger2为我们提供了@Singleton注解,和名字一样,这个注解的作用就是声明单例模式,我们先看看它怎么使用,下面再讲原理. 首先,在getRedCloth方法上添加该注解:\n@Singleton @Provides public Cloth getRedCloth() { Cloth cloth = new Cloth(); cloth.setColor(\u0026#34;红色\u0026#34;); return cloth; } 再在MainComponent接口上添加该注解:\n@Singleton @Component(modules=MainModule.class) public interface MainComponent { void inject(MainActivity mainActivity); } 我们看看运行结果:\n有没有发现,MainActivity中的Cloth对象和Clothes中的Cloth对象是同一个对象了,是不是很神奇!\n@Scope @Singleton是怎么实现的呢?我们先看看@Scope注解,弄懂它,@Singleton你也就会明白了,下面我们就来分析分析 顾名思义,@Scope就是用来声明作用范围的.@Scope和@Qulifier一样,需要我们自定义注解才能使用,我们先自定义一个注解:\n@Scope @Retention(RetentionPolicy.RUNTIME) public @interface PerActivity { } 这个注解有什么用呢?答案就是声明作用范围,当我们将这个注解使用在Module类中的Provide方法上时,就是声明这个Provide方法是在PerActivity作用范围内的,并且当一个Component要引用这个Module时,必须也要声明这个Component是PerActivity作用范围内的,否则就会报错,声明方法也很简单,就是在Component接口上使用这个注解.但是我们声明这个作用范围又有什么用呢?原来Dagger2有这样一个机制:在同一个作用范围内,Provide方法提供的依赖对象就会变成单例,也就是说依赖需求方不管依赖几次Provide方法提供的依赖对象,Dagger2都只会调用一次这个方法.就和上面那个例子一样,正常情况下,在注入MainActivity中的Cloth对象时会调用一次getRedCloth方法,注入Clothes对象时因为依赖Cloth对象,所以又会调用一次getRedCloth方法,导致这两个Cloth对象并不是同一个实例.但是我们给它声明作用范围后,这两次对Cloth的依赖只会调用一次getRedCloth方法,这样这两个Cloth对象就是同一实例了,这样就保证了在给MainActivity注入时,所有声明的Cloth依赖都是指向同一个实例.(注意:只有Module类中声明了作用范围的Provide方法才能实现单例,没声明的方法就不是单例的) 查看源码你会发现Singleton其实是继承@Scope注解的,所以你知道了Singleton是怎么实现单例模式的吧. 可能有些读者可能会问,Dagger2既然有了Singleton为什么还要我们自定义PerActivity注解?这就涉及到代码可读性了,当依赖需求方是Activity时,我们可以自定义一个PerActivity注解,当依赖需求方是Fragment时,我们又可以自定义一个PerFragment注解,这样我们就能清楚的区分依赖对象的提供目标了 那我们通过构造函数提供依赖的方式又要怎么声明作用范围呢?答案就是在类名上使用注解标明,切记不要在构造函数上用注解标明,这样是无效的. 读者可以试试用PerActivity注解代替上面例子中的Singleton注解,你会发现效果是一样的\n注意注意注意:单例是在同一个Component实例提供依赖的前提下才有效的,不同的Component实例只能通过Component依赖才能实现单例.也就是说,你虽然在两个Component接口上都添加了PerActivity注解,但是这两个Component提供依赖时是没有联系的,他们只能在各自的范围内实现单例.(下一个例子会体现到)\n组件依赖dependencies的使用 在实际开发中,我们经常会使用到工具类,工具类一般在整个App的生命周期内都是单例的,我们现在给我们的Demo添加一个工具类ClothHandler:\npublic class ClothHandler { public Clothes handle(Cloth cloth){ return new Clothes(cloth); } } 它的功能就是将cloth加工成clothes,假设我们现在有两个Activity中都要使用该工具类,我们要怎么使用Dagger2帮我们注入呢? 我们先用上面所学的方法试试,先在MainModule中添加提供方法:\n@Module public class MainModule { @PerActivity @Provides public Cloth getRedCloth() { Cloth cloth = new Cloth(); cloth.setColor(\u0026#34;红色\u0026#34;); return cloth; } @PerActivity @Provides public ClothHandler getClothHandler(){ return new ClothHandler(); } } 再在MainActivity中声明依赖:\npublic class MainActivity extends AppCompatActivity { private TextView tv; @Inject Cloth redCloth; @Inject ClothHandler clothHandler; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv = (TextView) findViewById(R.id.tv); MainComponent build = DaggerMainComponent.builder().mainModule(new MainModule()).build(); build.inject(this); tv.setText(\u0026#34;红布料加工后变成了\u0026#34; + clothHandler.handle(redCloth) + \u0026#34;\\nclothHandler地址:\u0026#34; + clothHandler); } //在布局文件中声明的点击方法 public void onClick(View v){ Intent intent = new Intent(this,SecondActivity.class); startActivity(intent); } } 同理在书写第二个Activity,并为它书写Module类Component接口:\npublic class SecondActivity extends AppCompatActivity { private TextView tv; @Inject Cloth blueCloth; @Inject ClothHandler clothHandler; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); tv = (TextView) findViewById(R.id.tv); SecondComponent component = DaggerSecondComponent.builder().secondModule(new SecondModule()).build(); component.inject(this); tv.setText(\u0026#34;蓝布料加工后变成了\u0026#34; + clothHandler.handle(blueCloth) + \u0026#34;\\nclothHandler地址:\u0026#34; + clothHandler); } } @Module public class SecondModule { @PerActivity @Provides public Cloth getBlueCloth(){ Cloth cloth = new Cloth(); cloth.setColor(\u0026#34;蓝色\u0026#34;); return cloth; } @PerActivity @Provides public ClothHandler getClothHandler(){ return new ClothHandler(); } } @PerActivity @Component(modules = SecondModule.class) public interface SecondComponent { void inject(SecondActivity secondActivity); } 我们来看看结果:\n你会发现,虽然我们成功的将ClothHandler注入到了这两个Activity中,但是你会发现,这两个Activity中的ClothHandler实例不是一样的(验证了上面那个结论),并且我们发现这种注入方式要在每一个Module中都要提供getClothHandler方法, 假如有20个Activity都需要用到ClothHandler,那我们都这样写,不就代码重复了吗.并且我们还要实现单例,怎么办呢?Dagger2很贴心的为我们提供了Component依赖,就能完美的解决这个问题. 在面向对象的思想中,我们碰到这种情况一般都要抽取父类,Dagger2也是用的这种思想,我们先创建一个BaseModule,用来提供工具类:\n@Module public class BaseModule { @Singleton //单例 @Provides public ClothHandler getClothHandler(){ return new ClothHandler(); } } 在创建一个BaseComponent接口:\n@Singleton //对应Module中声明的单例 @Component(modules = BaseModule.class) public interface BaseComponent { ClothHandler getClothHandler(); } 嗯?这个Component怎么有点不一样,怎么没有inject方法呢?上面讲过,我们通过inject方法依赖需求方实例送到Component中,从而帮助依赖需求方实现依赖,但是我们这个BaseComponent是给其他Component提供依赖的,所以我们就可以不用inject方法,但是BaseComponent中多了一个getClothHandler方法,它的返回值是ClothHandler对象,这个方法有什么用呢?它的作用就是告诉依赖于BaseComponent的Component,BaseComponent能为你们提供ClothHandler对象,如果没有这个方法,BaseComponent就不能提供ClothHandler对象(这个提供规则和上面的依赖规则相同,可以实现单例).既然有了BaseComponent,那我们就可在其它Component中依赖它了.我们删除MainModule和SecondModule中的getClothHandler方法:\n@Module public class MainModule { @PerActivity @Provides public Cloth getRedCloth() { Cloth cloth = new Cloth(); cloth.setColor(\u0026#34;红色\u0026#34;); return cloth; } } @Module public class SecondModule { @PerActivity @Provides public Cloth getBlueCloth(){ Cloth cloth = new Cloth(); cloth.setColor(\u0026#34;蓝色\u0026#34;); return cloth; } } 接下来在MainComponent和SecondComponent中声明依赖,就要用到@Component中的dependencies属性了:\n@PerActivity @Component(modules=MainModule.class,dependencies = BaseComponent.class) public interface MainComponent { void inject(MainActivity mainActivity); } @PerActivity @Component(modules = SecondModule.class,dependencies = BaseComponent.class) public interface SecondComponent { void inject(SecondActivity secondActivity); } 下面我们用Android Studio中build菜单下的Rebuild Object选项后,你会发现创建MainComponent和SecondComponent实例时多了一个baseComponent方法:\n这个方法需要我们传入一个BaseComponent实例,原因很简单,MainComponent和SecondComponent既然依赖BaseComponent,肯定需要你传入一个BaseComponent实例给它,它才能从BaseComponent实例中获取到它需要的对象嘛.但是需要注意的是,如果要MainComponent和SecondComponent依赖到的对象是同一个的话(也就是单例),创建它们是传入的BaseComponent实例也必须是同一个,上面说过,不同的Component实例是无法提供相同的依赖实例的,因为它们之间是没有联系的.这样的话,我们就需要在MainActivity和SecondActivity中能获取到同一个BaseComponent实例,怎么样能实现呢?很多人一开始都会想到用静态工厂,这种方法可行,但是我们一般都会自定义一个Application类,用它来提供BaseComponent实例,因为在整个App生命周期内都只有一个Application实例,所以其中的BaseComponent实例也不会变.我们自定义一个MyApplication类\npublic class MyApplication extends Application { private BaseComponent baseComponent; @Override public void onCreate() { super.onCreate(); baseComponent = DaggerBaseComponent.builder().baseModule(new BaseModule()).build(); } public BaseComponent getBaseComponent() { return baseComponent; } } 我们在onCreate方法中创建BaseComponent实例,并对外提供获取方法. 这种方式还有一种好处,就是当我们在BaseModule中需要用到Application实例时,我们就可以在创建BaseModule时传入this. 接下来在AndroidManifest.xml中声明我们新建的MyApplication:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest package=\u0026#34;cn.izouxiang.dagger2demo2\u0026#34; xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;application android:name=\u0026#34;.MyApplication\u0026#34; android:allowBackup=\u0026#34;true\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; android:supportsRtl=\u0026#34;true\u0026#34; android:theme=\u0026#34;@style/AppTheme\u0026#34;\u0026gt; \u0026lt;activity android:name=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;activity android:name=\u0026#34;.SecondActivity\u0026#34;\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 接下来修改MainActivity和SecondActivity中的代码:\npublic class MainActivity extends AppCompatActivity { ... @Override protected void onCreate(Bundle savedInstanceState) { ... MainComponent build = DaggerMainComponent .builder() .baseComponent(((MyApplication)getApplication()).getBaseComponent()) .mainModule(new MainModule()) .build(); build.inject(this); tv.setText(\u0026#34;红布料加工后变成了\u0026#34; + clothHandler.handle(redCloth) + \u0026#34;\\nclothHandler地址:\u0026#34; + clothHandler); } ... } public class SecondActivity extends AppCompatActivity { ... @Override protected void onCreate(Bundle savedInstanceState) { ... SecondComponent component = DaggerSecondComponent .builder() .baseComponent(((MyApplication)getApplication()).getBaseComponent()) .secondModule(new SecondModule()) .build(); component.inject(this); tv.setText(\u0026#34;蓝布料加工后变成了\u0026#34; + clothHandler.handle(blueCloth) + \u0026#34;\\nclothHandler地址:\u0026#34; + clothHandler); } } 运行结果:\n我们成功的将ClothHandler注入到了这两个Activity中,并且还实现了单例.(注意:这里能实现单例跟BaseComponent中声明了@Singleton有很大关系,因为BaseComponent都没有单例的话,外部依赖它的Component就更不可能单例了).\n@Subcomponent注解 @Subcomponent注解的功能和component依赖类似,但是使用方法有点不同,component依赖需要在被依赖的Component(下文中称为父组件)中暴露接口,没有暴露接口的类型在依赖方Component(下文中称为子组件)是获取不到的,但是通过@Subcomponent,子组件可以获取到所有父组件能提供的类型,下面我们来看看@Subcomponent注解的使用方法: 先声明一个SubMainComponent组件接口,这里的声明方式和最基本的Component接口声明方式差别不大,只是要将接口上的@Component注解改为@Subcomponent注解\n@PerActivity @Subcomponent(modules = MainModule.class) public interface SubMainComponent { void inject(MainActivity activity); } 这一步是重点,我们需要在父组件中声明一个返回值为子组件的方法,当子组件需要什么Module时,就在该方法中添加该类型的参数\n@Singleton @Component(modules = BaseModule.class) public interface BaseComponent { //这个是为第二个Activity准备的,也就是dependencies依赖声明的方式 ClothHandler getClothHandler(); //@Subcomponent使用的声明方式,声明一个返回值为子组件的方法,子组件需要什么Module,就在方法参数中添加什么 SubMainComponent getSubMainComponent(MainModule module); } 最后修改MainActivity:还是先获取到BaseComponent,再调用getSubMainComponent()方法,当中传入SubMainComponent组件需要的MainModule,这样我们就获取到了继承了BaseComponent组件的SubMainComponent组件,再调用一下inject方法完成注入就ok了\n@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv = (TextView) findViewById(R.id.tv); MyApplication application = (MyApplication) getApplication(); application.getBaseComponent().getSubMainComponent(new MainModule()).inject(this); tv.setText(\u0026#34;红布料加工后变成了\u0026#34; + clothHandler.handle(redCloth) + \u0026#34;\\nclothHandler地址:\u0026#34; + clothHandler); } 最后查看结果\n这里我们发现,虽然第一个Activity使用的是@subcomponent方式,第二个使用的是dependencies依赖的方式,但是ClothHandler还是实现了单例,出现这个原因我们上面也讲到了,因为这两个Activity中用到的BaseComponent是同一个实例,因为在BaseComponent中ClothHandler是单例的,那么通过BaseComponent提供的ClothHandler的肯定也是单例的嘛 这里总结一下@Subcomponent的使用:\n子组件的声明方式由@Component改为@Subcomponent 在父组件中要声明一个返回值为子组件的方法,当子组件需要什么Module时,就在该方法中添加该类型的参数 注意:用@Subcomponent注解声明的Component是无法单独使用的,想要获取该Component实例必须经过其父组件\nLazy与Provider Lazy和Provider都是用于包装Container中需要被注入的类型,Lazy用于延迟加载,所谓的懒加载就是当你需要用到该依赖对象时,Dagger2才帮你去获取一个;Provide用于强制重新加载,也就是每一要用到依赖对象时,Dagger2都会帮你依赖注入一次,下面我们来看个小例子: 修改MainModule类\n@Module public class MainModule { private static final String TAG = \u0026#34;MainModule\u0026#34;; //注意:这里没有声明作用域内单例 @Provides public Cloth getRedCloth() { Log.d(TAG, \u0026#34;getRedCloth: ...\u0026#34;); Cloth cloth = new Cloth(); cloth.setColor(\u0026#34;红色\u0026#34;); return cloth; } //注意:这里没有声明作用域内单例 @Provides public Shoe getShoe(){ Log.d(TAG, \u0026#34;getShoe: ...\u0026#34;); return new Shoe(); } } 再修改MainActivity类\npublic class MainActivity extends AppCompatActivity { private static final String TAG = \u0026#34;MainActivity\u0026#34;; @Inject //Lazy声明方式 Lazy\u0026lt;Cloth\u0026gt; redCloth; @Inject //Provider声明方式 Provider\u0026lt;Shoe\u0026gt; shoe; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv = (TextView) findViewById(R.id.tv); MyApplication application = (MyApplication) getApplication(); //这里虽然没使用到BaseComponent,但是我们还是得传入BaseComponent,不然Dagger2会报错 MainComponent component = DaggerMainComponent.builder().baseComponent(application.getBaseComponent()).mainModule(new MainModule()).build(); component.inject(this); Log.d(TAG, \u0026#34;inject done ...\u0026#34;); Log.d(TAG, \u0026#34;1 use redCloth instance ..\u0026#34;); Log.d(TAG, \u0026#34;redCloth:\u0026#34; + redCloth.get()); Log.d(TAG, \u0026#34;2 use redCloth instance ..\u0026#34;); Log.d(TAG, \u0026#34;redCloth:\u0026#34; + redCloth.get()); Log.d(TAG, \u0026#34;1 use shoe instance ..\u0026#34;); Log.d(TAG, \u0026#34;shoe:\u0026#34; + shoe.get()); Log.d(TAG, \u0026#34;2 use shoe instance ..\u0026#34;); Log.d(TAG, \u0026#34;shoe:\u0026#34; + shoe.get()); } public void onClick(View v) { Intent intent = new Intent(this, SecondActivity.class); startActivity(intent); } } 其中Lazy和Provider的使用方法就是使用该类作为字段,泛型类型就是你要依赖的类型,当我们要获取该对象时,使用该类的get方法就行了. 下面我们来看看运行结果\n你会发现,cloth和shoe都是使用时才去调用module中的方法,不同的是,cloth只会调用一次,而shoe每次都会调用module中的方法,即对shoe重新注入,这也就是Lazy和Provider的区别. 上面的MainModule中是没有声明作用域内单例的,现在我们声明一下再看看结果有没有什么变化: 修改MainModule\n@Module public class MainModule { private static final String TAG = \u0026#34;MainModule\u0026#34;; @PerActivity //这里声明作用域内单例 @Provides public Cloth getRedCloth() { Log.d(TAG, \u0026#34;getRedCloth: ...\u0026#34;); Cloth cloth = new Cloth(); cloth.setColor(\u0026#34;红色\u0026#34;); return cloth; } @PerActivity //这里声明作用域内单例 @Provides public Shoe getShoe(){ Log.d(TAG, \u0026#34;getShoe: ...\u0026#34;); return new Shoe(); } } 查看结果:\n发现,声明单例后,使用shoe时也不会每次都去调用module中的方法了,这是因为Provider的作用是每次使用时都对依赖对象重新注入,但是Shoe在Component中是单例的,所以每次注入的都是同一个实例,所以只会调用一次module中的方法.\nComponent的生命周期 一般情况下我们都是在Activity的onCreate方法中创建Component实例,再调用inject方法完成依赖.所以Component依赖可以分为三个过程:\n创建Component实例 MainComponent component = DaggerMainComponent .builder() .baseComponent(((MyApplication)getApplication()).getBaseComponent()) .mainModule(new MainModule()) .build(); 调用inject方法 component.inject(this); 调用完这个方法整个依赖就完成了. Component实例被销毁 onCreate()方法调用完成后,Component实例就会因为没有被引用而被垃圾回收器回收.其中传入给Component实例的Module实例也会一同被回收,这也就能说明不同的Component实例之间是没有联系的(Component依赖除外).这里需要注意的是,使用Lazy和Provider时,与该依赖对象有关的Module实例会被Lazy和Provider引用,所以该Module实例不会被垃圾回收器回收 总结 至此,Dagger2基础已讲完,对于Dagger2在项目中的使用方法,可以参考github上的开源项目.希望此篇文章能够对你有所帮助! 本篇文章是笔者用来记录自己对Dagger2的理解的,如果当中有错误,还请赐教,以便笔者纠正. 能够书写本篇文章,还得多亏了各位大神的blog,正因为各位大神的分享精神,才让我们这种小菜鸟能够成长.此篇文章分享出来的目的也就是为了传承这种精神 最后我们引用一下Dagger2 Scope 注解能保证依赖在 component 生命周期内的单例性吗？中的注意事项:\ncomponent 的 inject 函数不要声明基类参数； Scope 注解必须用在 module 的 provide 方法上，否则并不能达到局部单例的效果； 如果 module 的 provide 方法使用了 scope 注解，那么 component 就必须使用同一个注解，否则编译会失败； 如果 module 的 provide 方法没有使用 scope 注解，那么 component 和 module 是否加注解都无关紧要，可以通过编译，但是没有局部单例效果； 对于直接使用 @Inject 构造函数的依赖，如果把 scope 注解放到它的类上，而不是构造函数上，就能达到局部单例的效果了； 笔者再总结\n被依赖的Component能提供某个对象时,一定要在接口中声明以该对象为返回值的方法(也就是暴露接口).这样依赖它的Component才能获取到这种对象. 声明 本文为笔者原创文章,转载需说明!\n参考文章 依赖注入神器：Dagger2详解系列 Dagger2 Scope 注解能保证依赖在 component 生命周期内的单例性吗？ GeekNews Dagger2图文完全教程 Android常用开源工具（2）-Dagger2进阶\n","permalink":"https://blog.fxzou.com/post/android/dagger2/","summary":"\u003cp\u003eDagger2是Android中比较热门的依赖注入框架, 本文将从初学者的角度来学习Dagger2。\u003c/p\u003e","title":"Dagger2入门，以初学者角度"},{"content":" 本文主要讲解怎么用贝塞尔曲线将多点连成一条平滑的曲线，若不了解贝塞尔曲线的同学可以查看这里\n先看效果 确定控制点 使用贝塞尔曲线,我们就要先找出它的控制点,笔者Google后发现了此篇文章,文章中列出了找出控制点的公式 注意:\n公式中的当前点是线段的起点,文中的当前点指的是线段的终点 公式中的a,b代表曲线的弯曲指数,越大代表曲线越弯,一般设置0.16 从公式中可以发现,确定当前点的控制点,需要用到当前点的前两个点和下一个点四个点,那么当当前点是第一个点,第二个点和最后一个点时,我们就无法获取到全部点,那篇文章中又指出 第二种方法过于复杂,文中使用的是第一中方法,即用当前点的值表示无法获取到的点的值, 下面列出代码:\nprivate void measurePath() { //保存曲线路径 mPath = new Path(); //保存辅助线路径 mAssistPath = new Path(); float prePreviousPointX = Float.NaN; float prePreviousPointY = Float.NaN; float previousPointX = Float.NaN; float previousPointY = Float.NaN; float currentPointX = Float.NaN; float currentPointY = Float.NaN; float nextPointX; float nextPointY; final int lineSize = mPointList.size(); for (int valueIndex = 0; valueIndex \u0026lt; lineSize; ++valueIndex) { if (Float.isNaN(currentPointX)) { Point point = mPointList.get(valueIndex); currentPointX = point.x; currentPointY = point.y; } if (Float.isNaN(previousPointX)) { //是否是第一个点 if (valueIndex \u0026gt; 0) { Point point = mPointList.get(valueIndex - 1); previousPointX = point.x; previousPointY = point.y; } else { //是的话就用当前点表示上一个点 previousPointX = currentPointX; previousPointY = currentPointY; } } if (Float.isNaN(prePreviousPointX)) { //是否是前两个点 if (valueIndex \u0026gt; 1) { Point point = mPointList.get(valueIndex - 2); prePreviousPointX = point.x; prePreviousPointY = point.y; } else { //是的话就用当前点表示上上个点 prePreviousPointX = previousPointX; prePreviousPointY = previousPointY; } } // 判断是不是最后一个点了 if (valueIndex \u0026lt; lineSize - 1) { Point point = mPointList.get(valueIndex + 1); nextPointX = point.x; nextPointY = point.y; } else { //是的话就用当前点表示下一个点 nextPointX = currentPointX; nextPointY = currentPointY; } if (valueIndex == 0) { // 将Path移动到开始点 mPath.moveTo(currentPointX, currentPointY); mAssistPath.moveTo(currentPointX, currentPointY); } else { // 求出控制点坐标 final float firstDiffX = (currentPointX - prePreviousPointX); final float firstDiffY = (currentPointY - prePreviousPointY); final float secondDiffX = (nextPointX - previousPointX); final float secondDiffY = (nextPointY - previousPointY); final float firstControlPointX = previousPointX + (lineSmoothness * firstDiffX); final float firstControlPointY = previousPointY + (lineSmoothness * firstDiffY); final float secondControlPointX = currentPointX - (lineSmoothness * secondDiffX); final float secondControlPointY = currentPointY - (lineSmoothness * secondDiffY); //画出曲线 mPath.cubicTo(firstControlPointX, firstControlPointY, secondControlPointX, secondControlPointY, currentPointX, currentPointY); //将控制点保存到辅助路径上 mAssistPath.lineTo(firstControlPointX, firstControlPointY); mAssistPath.lineTo(secondControlPointX, secondControlPointY); mAssistPath.lineTo(currentPointX, currentPointY); } // 更新值, prePreviousPointX = previousPointX; prePreviousPointY = previousPointY; previousPointX = currentPointX; previousPointY = currentPointY; currentPointX = nextPointX; currentPointY = nextPointY; } mPathMeasure = new PathMeasure(mPath, false); } 参考博客 http://blog.csdn.net/u011102153/article/details/52039794 部分源码拷贝了该项目的源码 完整代码 https://github.com/zFxiang/BezierDemo 笔者还属于学习阶段,若文中有错误,还请赐教 ","permalink":"https://blog.fxzou.com/post/android/bezier/","summary":"","title":"Android-使用贝塞尔曲线将多点连成一条平滑的曲线"},{"content":"美化 原贴地址\n系统清理篇 //卸载自带的开源office软件 sudo apt-get remove libreoffice-common //删除Amazon的链接 sudo apt-get remove unity-webapps-common //删除不常用的软件 sudo apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot sudo apt-get remove gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku landscape-client-ui-install sudo apt-get remove onboard deja-dup //更新一些补丁 sudo apt-get update sudo apt-get upgrade 主题美化篇 //安装unity-tweak-tool sudo apt-get install unity-tweak-tool //安装Flatabulous主题 sudo add-apt-repository ppa:noobslab/themes sudo apt-get update sudo apt-get install flatabulous-theme //安装配套的图标 sudo add-apt-repository ppa:noobslab/icons sudo apt-get update sudo apt-get install ultra-flat-icons //打开unity-tweak-tool软件，修改主题和图标，主题选择Flatabulous，图标选择Ultra-flat 解决浏览器总是提示找不到服务器的问题 原贴地址\n//修改文件，将nameserver后面的IP改为你想要的DNS服务器IP，谷歌提供的免费dns服务器地址8.8.8.8 sudo vim /etc/resolv.conf //再修改文件,在打开的这个文件中添加：nameserver 你在上面写的DNS IP（也就是拷贝上面修改的那一行） sudo vim /etc/resolvconf/resolv.conf.d/head 解决和盖或外接显示器睡眠后无法唤醒，输入密码错误 原贴地址1（休眠问题） 原贴地址2（鼠标问题）\n//检查是否安装了grep laptop-mode-tools 工具包，如果执行命令无结果输出，表示未安装(如果已安装，忽略第2步) dpkg -l | grep laptop-mode-tools //安装laptop-mode sudo apt-get install laptop-mode-tools //判断Laptop是否启用了laptop_mode模式,如果显示结果为0，则表示未启动，如果为非0的数字则表示启动了 cat /proc/sys/vm/laptop_mode //修改文件,更改 ENABLE_LAPTOP_MODE=true,，如果在此文件中没找到该字段，则要进行下一步 sudo vim /etc/default/acpi-support //（解决上一步骤问题，上一步正常的可以跳过）修改文件,将 //ENABLE_LAPTOP_MODE_ON_BATTERY、 //ENABLE_LAPTOP_MODE_ON_AC、 //ENABLE_LAPTOP_MODE_WHEN_LID_CLOSED //全部设为1 sudo vim /etc/laptop-mode/laptop-mode.conf //启动了laptop_mode sudo laptop_mode start //再次判断Laptop是否启用了laptop_mode模式，如果显示结果为0，则表示未启动，如果为非0的数字则表示启动了 cat /proc/sys/vm/laptop_mode //这时候如果正常启动了，就成功了 //但是如果发现鼠标自动休眠的话，还要进行以下操作 //修改文件,令AUTOSUSPEND_RUNTIME_DEVTYPE_BLACKLIST=\u0026#34;usbhid usb-storage\u0026#34;，保存后重启电脑后鼠标即不会再次自动断电了。 sudo vim /etc/laptop-mode/conf.d/runtime-pm.conf 观看视频时取消自动休眠 原贴地址\nsudo add-apt-repository ppa:caffeine-developers/ppa sudo apt-get update sudo apt-get install caffeine //打开软件后状态栏会出现一个咖啡杯图标，右键激活就行了 Sublime Text 2/3中文输入问题 原贴地址\n//若没安装git请先安装git（sudo apt-get install git） git clone https://github.com/lyfeyaj/sublime-text-imfix.git cd sublime-text-imfix ./sublime-imfix //重启软件 去除打开软件需要输入凭证密码 //打开凭证管理器，将该凭证的密码改为无（右键修改密码，输入旧密码后不输入新密码直接点击继续） seahorse idea 或 android studio 快捷键冲突的解决办法 系统设置 \u0026gt; 键盘 \u0026gt; 快捷键 ，再逐个查找其中冲突的快捷键，将它修改或禁用\n安装搜狗输入法 //添加源 sudo add-apt-repository ppa:fcitx-team/nightly //安装fcitx sudo apt-get install fcitx fcitx-config-gtk fcitx-table-all fcitx-frontend-qt5:amd64 fcitx-uilassic //官网下载deb安装 其他修改 其它非必须操作请参考这篇博客安装ubuntu16.04后要做的9件事 各种软件安装请自行google，此片文章没有图片，若看不懂请点开原文链接。 不定时更新！\n","permalink":"https://blog.fxzou.com/post/ubuntu/ubuntu_16_4/","summary":"","title":"ubuntu16.4 系统安装后的优化整理"}]